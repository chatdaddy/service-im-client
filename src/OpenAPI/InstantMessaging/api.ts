/* tslint:disable */
/* eslint-disable */
/**
 * Instant Messaging Service
 * Complete instant messaging API for WhatsApp Web & Multi-Device. 
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Account ID of the user
     * @type {string}
     * @memberof Account
     */
    accountId: string;
    /**
     * Owner of thr account
     * @type {string}
     * @memberof Account
     */
    ownerId: string;
    /**
     * User facing nickname of the account
     * @type {string}
     * @memberof Account
     */
    nickname: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    credentials?: { [key: string]: any; } | null;
    /**
     * 
     * @type {AccountType}
     * @memberof Account
     */
    type: AccountType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    createdAt: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    updatedAt: string;
    /**
     * 
     * @type {State}
     * @memberof Account
     */
    state: State;
    /**
     * 
     * @type {AccountError}
     * @memberof Account
     */
    error?: AccountError | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    stateInfo: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    canLogin: boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Account
     */
    user?: Contact;
    /**
     * 
     * @type {AccountSettings}
     * @memberof Account
     */
    settings: AccountSettings;
}
/**
 * 
 * @export
 * @interface AccountError
 */
export interface AccountError {
    /**
     * 
     * @type {string}
     * @memberof AccountError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface AccountSettings
 */
export interface AccountSettings {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountSettings
     */
    notifyUsers?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AccountType {
    Wa = 'wa',
    WaMd = 'wa-md',
    Mock = 'mock'
}

/**
 * Update an account. Specifying account updates the type
 * @export
 * @interface AccountsPatchRequest
 */
export interface AccountsPatchRequest {
    /**
     * 
     * @type {AccountType}
     * @memberof AccountsPatchRequest
     */
    type?: AccountType;
    /**
     * 
     * @type {string}
     * @memberof AccountsPatchRequest
     */
    nickname?: string;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPatchRequest
     */
    settings?: AccountSettings;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * account it belongs to
     * @type {string}
     * @memberof Chat
     */
    accountId: string;
    /**
     * chat ID
     * @type {string}
     * @memberof Chat
     */
    id: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chat
     */
    lastMessage: string;
    /**
     * Number of unread messages
     * @type {number}
     * @memberof Chat
     */
    unread: number;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    spam?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    archive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    readOnly: boolean;
    /**
     * Timestamp of when the chat was muted
     * @type {number}
     * @memberof Chat
     */
    mute?: number | null;
    /**
     * Timestamp of when the chat was pinned
     * @type {number}
     * @memberof Chat
     */
    pin?: number | null;
    /**
     * did the user create this contact
     * @type {boolean}
     * @memberof Chat
     */
    isUserGenerated: boolean;
    /**
     * does this chat have any pending messages
     * @type {boolean}
     * @memberof Chat
     */
    hasPendingMessage?: boolean;
    /**
     * does this chat have any unsolved notes
     * @type {boolean}
     * @memberof Chat
     */
    hasUnsolvedNote?: boolean;
    /**
     * the user IDs mentioned in the chat
     * @type {Array<string>}
     * @memberof Chat
     */
    mentions?: Array<string>;
    /**
     * if disappearing messages is on, and for how long
     * @type {number}
     * @memberof Chat
     */
    disappearingMessages?: number | null;
    /**
     * 
     * @type {Contact}
     * @memberof Chat
     */
    contact: Contact;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Chat
     */
    messages?: Array<Message>;
    /**
     * 
     * @type {Array<ChatPresence>}
     * @memberof Chat
     */
    presences?: Array<ChatPresence>;
    /**
     * cursor to sort chats by
     * @type {string}
     * @memberof Chat
     */
    cursor: string;
}
/**
 * 
 * @export
 * @interface ChatAction
 */
export interface ChatAction {
    /**
     * 
     * @type {string}
     * @memberof ChatAction
     */
    action: ChatActionActionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatAction
     */
    value: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ChatActionActionEnum {
    Archive = 'archive',
    Pin = 'pin',
    Mute = 'mute',
    Read = 'read',
    Delete = 'delete'
}

/**
 * 
 * @export
 * @interface ChatPresence
 */
export interface ChatPresence {
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    contactId: string;
    /**
     * if a known team member has this presence
     * @type {string}
     * @memberof ChatPresence
     */
    userId?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ChatPresence
     */
    updatedAt: string;
    /**
     * 
     * @type {PresenceType}
     * @memberof ChatPresence
     */
    type: PresenceType;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * contact ID for the platform
     * @type {string}
     * @memberof Contact
     */
    id: string;
    /**
     * The account this is part of
     * @type {string}
     * @memberof Contact
     */
    accountId: string;
    /**
     * 
     * @type {ContactType}
     * @memberof Contact
     */
    type: ContactType;
    /**
     * name of the contact as set on ChatDaddy
     * @type {string}
     * @memberof Contact
     */
    name: string | null;
    /**
     * name of the contact, as set on the platform
     * @type {Array<string>}
     * @memberof Contact
     */
    platformNames: Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    createdAt?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    phoneNumber: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    email?: string | null;
    /**
     * 
     * @type {ContactImg}
     * @memberof Contact
     */
    img?: ContactImg | null;
    /**
     * Tags associated with this contact
     * @type {Array<Tag>}
     * @memberof Contact
     */
    tags: Array<Tag>;
    /**
     * The assignee of the contact
     * @type {string}
     * @memberof Contact
     */
    assignee?: string | null;
    /**
     * The person who assigned this contact
     * @type {string}
     * @memberof Contact
     */
    assigner?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    messagesSent: number;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    messagesReceived: number;
}
/**
 * 
 * @export
 * @interface ContactImg
 */
export interface ContactImg {
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    url?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactImg
     */
    fetchedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ContactType {
    Individual = 'individual',
    Group = 'group',
    Broadcast = 'broadcast'
}

/**
 * 
 * @export
 * @interface ContactsPatch
 */
export interface ContactsPatch {
    /**
     * 
     * @type {ContactsPatchPatch}
     * @memberof ContactsPatch
     */
    patch: ContactsPatchPatch;
}
/**
 * 
 * @export
 * @interface ContactsPatchPatch
 */
export interface ContactsPatchPatch {
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    assignee?: string | null;
    /**
     * 
     * @type {Array<ContactsPatchPatchTags>}
     * @memberof ContactsPatchPatch
     */
    tags?: Array<ContactsPatchPatchTags>;
}
/**
 * 
 * @export
 * @interface ContactsPatchPatchTags
 */
export interface ContactsPatchPatchTags {
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatchTags
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactsPatchPatchTags
     */
    remove?: boolean;
}
/**
 * 
 * @export
 * @interface ContactsPost
 */
export interface ContactsPost {
    /**
     * 
     * @type {Array<ContactsPostContacts>}
     * @memberof ContactsPost
     */
    contacts: Array<ContactsPostContacts>;
}
/**
 * 
 * @export
 * @interface ContactsPostContacts
 */
export interface ContactsPostContacts {
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContacts
     */
    name: string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof ContactsPostContacts
     */
    phoneNumber: string;
    /**
     * The email of the contact
     * @type {string}
     * @memberof ContactsPostContacts
     */
    email?: string;
    /**
     * Tags to set on this contact. These tags don\'t have to exist on the DB beforehand
     * @type {Array<string>}
     * @memberof ContactsPostContacts
     */
    tags?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface DataModel
 */
export interface DataModel {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DataModel
     */
    fromDate: string;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    messagesSent: DataModelInner;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    tasksCompleted: DataModelInner;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    tasksAdded: DataModelInner;
}
/**
 * 
 * @export
 * @interface DataModelInner
 */
export interface DataModelInner {
    /**
     * 
     * @type {Array<object>}
     * @memberof DataModelInner
     */
    byUserId: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof DataModelInner
     */
    byChatId?: Array<object>;
}
/**
 * @type GroupAction
 * @export
 */
export type GroupAction = GroupActionOneOf | GroupActionOneOf1 | GroupActionOneOf2 | GroupActionOneOf3;

/**
 * 
 * @export
 * @interface GroupActionOneOf
 */
export interface GroupActionOneOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupActionOneOf
     */
    add: Array<string>;
}
/**
 * 
 * @export
 * @interface GroupActionOneOf1
 */
export interface GroupActionOneOf1 {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupActionOneOf1
     */
    remove: Array<string>;
}
/**
 * 
 * @export
 * @interface GroupActionOneOf2
 */
export interface GroupActionOneOf2 {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupActionOneOf2
     */
    promote: Array<string>;
}
/**
 * 
 * @export
 * @interface GroupActionOneOf3
 */
export interface GroupActionOneOf3 {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupActionOneOf3
     */
    demote: Array<string>;
}
/**
 * 
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    participants: Array<string>;
}
/**
 * 
 * @export
 * @interface GroupMetadata
 */
export interface GroupMetadata {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    accountId: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GroupMetadata
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    ownerId?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof GroupMetadata
     */
    owner?: Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    description: string | null;
    /**
     * is set when the group only allows admins to change group settings
     * @type {boolean}
     * @memberof GroupMetadata
     */
    restrict: boolean;
    /**
     * is set when the group only allows admins to write messages
     * @type {boolean}
     * @memberof GroupMetadata
     */
    announce: boolean;
    /**
     * 
     * @type {Array<GroupParticipant>}
     * @memberof GroupMetadata
     */
    participants: Array<GroupParticipant>;
}
/**
 * 
 * @export
 * @interface GroupParticipant
 */
export interface GroupParticipant {
    /**
     * 
     * @type {Contact}
     * @memberof GroupParticipant
     */
    contact: Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipant
     */
    admin?: GroupParticipantAdminEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GroupParticipantAdminEnum {
    Admin = 'admin',
    SuperAdmin = 'super-admin'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {AccountType}
     * @memberof InlineObject
     */
    type: AccountType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    nickname?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject1
     */
    resolved?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    text?: string;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof InlineObject1
     */
    attachments?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    mentions?: Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof InlineObject1
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Account>}
     * @memberof InlineResponse200
     */
    accounts: Array<Account>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    success: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof InlineResponse2002
     */
    nextPage?: string;
    /**
     * number of total unread chats given the filter
     * @type {number}
     * @memberof InlineResponse2002
     */
    unreadChatCount?: number;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof InlineResponse2002
     */
    chats: Array<Chat>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    url: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    nextPage?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof InlineResponse2004
     */
    messages: Array<Message>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    nextPage?: number;
    /**
     * 
     * @type {Array<Message>}
     * @memberof InlineResponse2005
     */
    messages: Array<Message>;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof InlineResponse2005
     */
    chats?: Array<Chat>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    inviteCode: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * total contacts present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof InlineResponse2007
     */
    totalCount?: number;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof InlineResponse2007
     */
    contacts: Array<Contact>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    nextPage: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InlineResponse2008
     */
    tags: Array<Tag>;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    chatId: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    fromMe: boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof Message
     */
    senderContactId?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof Message
     */
    sender?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    timestamp: string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof Message
     */
    status?: MessageStatus;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Message
     */
    error?: { [key: string]: any; } | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof Message
     */
    resolvedBy?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    resolvedAt?: string | null;
    /**
     * 
     * @type {MiscOptions}
     * @memberof Message
     */
    miscOptions?: MiscOptions;
    /**
     * 
     * @type {Array<string>}
     * @memberof Message
     */
    mentions?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    text: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof Message
     */
    quoted?: QuotedMessage | null;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof Message
     */
    action?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof Message
     */
    attachments?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageContentButtons>}
     * @memberof Message
     */
    buttons?: Array<MessageContentButtons> | null;
}
/**
 * 
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOf
     */
    chatId: string;
    /**
     * 
     * @type {string}
     * @memberof MessageAllOf
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof MessageAllOf
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllOf
     */
    fromMe: boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof MessageAllOf
     */
    senderContactId?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof MessageAllOf
     */
    sender?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    timestamp: string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof MessageAllOf
     */
    status?: MessageStatus;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof MessageAllOf
     */
    error?: { [key: string]: any; } | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof MessageAllOf
     */
    resolvedBy?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    resolvedAt?: string | null;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageAllOf
     */
    miscOptions?: MiscOptions;
}
/**
 * The user ID of the person that sent it
 * @export
 * @interface MessageAllOfSender
 */
export interface MessageAllOfSender {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfSender
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface MessageAttachment
 */
export interface MessageAttachment {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof MessageAttachment
     */
    type: MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachment
     */
    mimetype: string;
    /**
     * 1. can be publicly hosted url,  2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` Note: the `contact` type only supports base64 encoded data 
     * @type {string}
     * @memberof MessageAttachment
     */
    url: string;
    /**
     * thumbnail of sticker/video/image
     * @type {any}
     * @memberof MessageAttachment
     */
    jpegThumbnail?: any;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof MessageAttachment
     */
    seconds?: number;
    /**
     * name of the doc message
     * @type {string}
     * @memberof MessageAttachment
     */
    filename?: string;
    /**
     * is this a gif
     * @type {boolean}
     * @memberof MessageAttachment
     */
    isGif?: boolean;
    /**
     * 
     * @type {MessageAttachmentDecryption}
     * @memberof MessageAttachment
     */
    decryption?: MessageAttachmentDecryption;
}
/**
 * 
 * @export
 * @interface MessageAttachmentDecryption
 */
export interface MessageAttachmentDecryption {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageAttachmentDecryption
     */
    keys?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentDecryption
     */
    algorithm: MessageAttachmentDecryptionAlgorithmEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageAttachmentDecryptionAlgorithmEnum {
    Aes256Cbc = 'aes-256-cbc'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MessageAttachmentType {
    Image = 'image',
    Video = 'video',
    Contact = 'contact',
    Sticker = 'sticker',
    Audio = 'audio',
    Document = 'document',
    Location = 'location'
}

/**
 * 
 * @export
 * @interface MessageCompose
 */
export interface MessageCompose {
    /**
     * Specify the message Id -- can be used to atomically send messages. Two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageCompose
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCompose
     */
    status: MessageComposeStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageCompose
     */
    timestamp?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageCompose
     */
    miscOptions?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageCompose
     */
    parameters?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageCompose
     */
    mentions?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MessageCompose
     */
    text: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageCompose
     */
    quoted?: QuotedMessage | null;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageCompose
     */
    action?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageCompose
     */
    attachments?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageContentButtons>}
     * @memberof MessageCompose
     */
    buttons?: Array<MessageContentButtons> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageComposeStatusEnum {
    Note = 'note',
    Pending = 'pending'
}

/**
 * 
 * @export
 * @interface MessageComposeAllOf
 */
export interface MessageComposeAllOf {
    /**
     * Specify the message Id -- can be used to atomically send messages. Two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    status: MessageComposeAllOfStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    timestamp?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageComposeAllOf
     */
    miscOptions?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageComposeAllOf
     */
    parameters?: { [key: string]: any; };
}

/**
    * @export
    * @enum {string}
    */
export enum MessageComposeAllOfStatusEnum {
    Note = 'note',
    Pending = 'pending'
}

/**
 * 
 * @export
 * @interface MessageContent
 */
export interface MessageContent {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContent
     */
    mentions?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MessageContent
     */
    text: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageContent
     */
    quoted?: QuotedMessage | null;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageContent
     */
    action?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageContent
     */
    attachments?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageContentButtons>}
     * @memberof MessageContent
     */
    buttons?: Array<MessageContentButtons> | null;
}
/**
 * 
 * @export
 * @interface MessageContentAction
 */
export interface MessageContentAction {
    /**
     * 
     * @type {string}
     * @memberof MessageContentAction
     */
    type: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContentAction
     */
    parameters?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessageContentButtons
 */
export interface MessageContentButtons {
    /**
     * 
     * @type {string}
     * @memberof MessageContentButtons
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentButtons
     */
    text: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MessageStatus {
    Error = 'error',
    Pending = 'pending',
    Note = 'note',
    Sent = 'sent',
    Delivered = 'delivered',
    Read = 'read'
}

/**
 * 
 * @export
 * @interface MiscOptions
 */
export interface MiscOptions {
    /**
     * Emulate typing behaviour before send
     * @type {boolean}
     * @memberof MiscOptions
     */
    withTyping?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MiscOptions
     */
    forwardCount?: number;
    /**
     * Adds random whitespace to produce a distinct message
     * @type {boolean}
     * @memberof MiscOptions
     */
    randomizeMessage?: boolean;
    /**
     * the ID of the button clicked
     * @type {string}
     * @memberof MiscOptions
     */
    buttonReplyId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PresenceType {
    Available = 'available',
    Unavailable = 'unavailable',
    Typing = 'typing',
    StoppedTyping = 'stoppedTyping'
}

/**
 * 
 * @export
 * @interface QuotedMessage
 */
export interface QuotedMessage {
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    chatId: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    senderContactId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    text?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    jpegThumbnail?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum State {
    Open = 'open',
    Connecting = 'connecting',
    Close = 'close'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * Unique name of Tag
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * The filters for a dynamic tag
     * @type {object}
     * @memberof Tag
     */
    filters?: object | null;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsClose', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/close`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsDelete', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsLogout', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/logout`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsOpen', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/open`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch: async (accountId: string, accountsPatchRequest?: AccountsPatchRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsPatch', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new account
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClose(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClose(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogout(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogout(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsOpen(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOpen(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPatch(accountId, accountsPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new account
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsClose(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(accountId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.accountsDelete(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(q?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.accountsGet(q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout(accountId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.accountsLogout(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsOpen(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.accountsPatch(accountId, accountsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new account
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(inlineObject?: InlineObject, options?: any): AxiosPromise<Account> {
            return localVarFp.accountsPost(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Close connection to the account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsClose(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).accountsClose(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsDelete(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).accountsDelete(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all accounts
     * @param {string} [q] search accounts by ID/Nickname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsGet(q?: string, options?: any) {
        return AccountApiFp(this.configuration).accountsGet(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout and clear credentials from the account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsLogout(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).accountsLogout(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open connection to the account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsOpen(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).accountsOpen(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an account
     * @param {string} accountId 
     * @param {AccountsPatchRequest} [accountsPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: any) {
        return AccountApiFp(this.configuration).accountsPatch(accountId, accountsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new account
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPost(inlineObject?: InlineObject, options?: any) {
        return AccountApiFp(this.configuration).accountsPost(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (hasPendingMessage !== undefined) {
                localVarQueryParameter['hasPendingMessage'] = hasPendingMessage;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (hasUnsolvedNote !== undefined) {
                localVarQueryParameter['hasUnsolvedNote'] = hasUnsolvedNote;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnUnreadChatCount !== undefined) {
                localVarQueryParameter['returnUnreadChatCount'] = returnUnreadChatCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch: async (accountId: string, id: string, chatAction?: ChatAction, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPatch', 'id', id)
            const localVarPath = `/chats/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost: async (accountId: string, id: string, presence: PresenceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPresencePost', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPresencePost', 'id', id)
            // verify required parameter 'presence' is not null or undefined
            assertParamExists('chatsPresencePost', 'presence', presence)
            const localVarPath = `/chats/{accountId}/{id}/presence`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ASSIGNED", "CHATS_ACCESS_ALL"], configuration)

            if (presence !== undefined) {
                localVarQueryParameter['presence'] = presence;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(count, page, archive, unread, hasPendingMessage, mentioned, hasUnsolvedNote, lastMessageFromMe, tags, contacts, q, assignee, accountId, type, returnUnreadChatCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPatch(accountId, id, chatAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPresencePost(accountId, id, presence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.chatsGet(count, page, archive, unread, hasPendingMessage, mentioned, hasUnsolvedNote, lastMessageFromMe, tags, contacts, q, assignee, accountId, type, returnUnreadChatCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: any): AxiosPromise<Chat> {
            return localVarFp.chatsPatch(accountId, id, chatAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.chatsPresencePost(accountId, id, presence, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * 
     * @summary Get chats
     * @param {number} [count] 
     * @param {string} [page] 
     * @param {boolean} [archive] 
     * @param {boolean} [unread] 
     * @param {boolean} [hasPendingMessage] 
     * @param {string} [mentioned] 
     * @param {boolean} [hasUnsolvedNote] 
     * @param {boolean} [lastMessageFromMe] 
     * @param {Array<string>} [tags] Get contacts who fall in either of these tags
     * @param {Array<string>} [contacts] Get these specific contact ids
     * @param {string} [q] Search string for contact name/phone number/email
     * @param {Array<string>} [assignee] Get contacts assigned to the specified users
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {'group' | 'individual'} [type] only get contacts of type
     * @param {boolean} [returnUnreadChatCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options?: any) {
        return ChatsApiFp(this.configuration).chatsGet(count, page, archive, unread, hasPendingMessage, mentioned, hasUnsolvedNote, lastMessageFromMe, tags, contacts, q, assignee, accountId, type, returnUnreadChatCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a chat -- read, unread, archive, pin etc.
     * @param {string} accountId 
     * @param {string} id 
     * @param {ChatAction} [chatAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: any) {
        return ChatsApiFp(this.configuration).chatsPatch(accountId, id, chatAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
     * @summary Update a chat\'s presence.
     * @param {string} accountId 
     * @param {string} id 
     * @param {PresenceType} presence 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: any) {
        return ChatsApiFp(this.configuration).chatsPresencePost(accountId, id, presence, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_DELETE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {string} [page] 
         * @param {number | string} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, page?: string, count?: number | string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL", "CONTACTS_READ_ASSIGNED"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet: async (id: string, accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsImageGet', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('contactsImageGet', 'accountId', accountId)
            const localVarPath = `/contacts/{accountId}/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', contactsPatch?: ContactsPatch, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_UPDATE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost: async (contactsPost?: ContactsPost, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDelete(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {string} [page] 
         * @param {number | string} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGet(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, page?: string, count?: number | string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, returnTotalCount, page, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsImageGet(id: string, accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsImageGet(id, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPatch(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', contactsPatch?: ContactsPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, contactsPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPost(contactsPost?: ContactsPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPost(contactsPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {string} [page] 
         * @param {number | string} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, page?: string, count?: number | string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, returnTotalCount, page, count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet(id: string, accountId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.contactsImageGet(id, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', contactsPatch?: ContactsPatch, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, contactsPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost(contactsPost?: ContactsPost, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.contactsPost(contactsPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * 
     * @summary Delete contacts
     * @param {Array<string>} [tags] Get contacts who fall in either of these tags
     * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
     * @param {Array<string>} [contacts] Get these specific contact ids
     * @param {Array<string>} [notContacts] Do not get these specific contacts
     * @param {number} [minMessagesSent] Minimum messages sent
     * @param {number} [minMessagesRecv] Minimum messages received
     * @param {number} [maxMessagesSent] Maximum messages sent
     * @param {number} [maxMessagesRecv] Maximum messages received
     * @param {string} [q] Search string for contact name/phone number/email
     * @param {Array<string>} [assignee] Get contacts assigned to the specified users
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {'group' | 'individual'} [type] only get contacts of type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsDelete(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any) {
        return ContactsApiFp(this.configuration).contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contacts
     * @param {Array<string>} [tags] Get contacts who fall in either of these tags
     * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
     * @param {Array<string>} [contacts] Get these specific contact ids
     * @param {Array<string>} [notContacts] Do not get these specific contacts
     * @param {number} [minMessagesSent] Minimum messages sent
     * @param {number} [minMessagesRecv] Minimum messages received
     * @param {number} [maxMessagesSent] Maximum messages sent
     * @param {number} [maxMessagesRecv] Maximum messages received
     * @param {string} [q] Search string for contact name/phone number/email
     * @param {Array<string>} [assignee] Get contacts assigned to the specified users
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {'group' | 'individual'} [type] only get contacts of type
     * @param {boolean} [returnTotalCount] 
     * @param {string} [page] 
     * @param {number | string} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsGet(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, page?: string, count?: number | string, options?: any) {
        return ContactsApiFp(this.configuration).contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, returnTotalCount, page, count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the display image of a contact
     * @param {string} id 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsImageGet(id: string, accountId: string, options?: any) {
        return ContactsApiFp(this.configuration).contactsImageGet(id, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update contacts
     * @param {Array<string>} [tags] Get contacts who fall in either of these tags
     * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
     * @param {Array<string>} [contacts] Get these specific contact ids
     * @param {Array<string>} [notContacts] Do not get these specific contacts
     * @param {number} [minMessagesSent] Minimum messages sent
     * @param {number} [minMessagesRecv] Minimum messages received
     * @param {number} [maxMessagesSent] Maximum messages sent
     * @param {number} [maxMessagesRecv] Maximum messages received
     * @param {string} [q] Search string for contact name/phone number/email
     * @param {Array<string>} [assignee] Get contacts assigned to the specified users
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {'group' | 'individual'} [type] only get contacts of type
     * @param {ContactsPatch} [contactsPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPatch(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', contactsPatch?: ContactsPatch, options?: any) {
        return ContactsApiFp(this.configuration).contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, contactsPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create contacts
     * @param {ContactsPost} [contactsPost] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPost(contactsPost?: ContactsPost, options?: any) {
        return ContactsApiFp(this.configuration).contactsPost(contactsPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (accountId?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(accountId?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(accountId?: Array<string>, options?: any): AxiosPromise<DataModel> {
            return localVarFp.dataGet(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
     * @summary Get the aggregate metadata
     * @param {Array<string>} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public dataGet(accountId?: Array<string>, options?: any) {
        return DataApiFp(this.configuration).dataGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost: async (mimetype: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mimetype' is not null or undefined
            assertParamExists('filesPost', 'mimetype', mimetype)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('filesPost', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPost(mimetype: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPost(mimetype, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(mimetype: string, name: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.filesPost(mimetype, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file to the media files bucket
     * @param {string} mimetype 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPost(mimetype: string, name: string, options?: any) {
        return FilesApiFp(this.configuration).filesPost(mimetype, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet: async (accountId: string, id: string, forceRefresh?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsGet', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsGet', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (forceRefresh !== undefined) {
                localVarQueryParameter['forceRefresh'] = forceRefresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode: async (accountId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsInviteCode', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsInviteCode', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/invite-code`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin: async (accountId: string, id: string, code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsJoin', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsJoin', 'id', id)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('groupsJoin', 'code', code)
            const localVarPath = `/groups/{accountId}/{id}/join`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave: async (accountId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsLeave', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsLeave', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/leave`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch: async (accountId: string, id: string, groupAction?: GroupAction, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsPatch', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost: async (accountId: string, groupCreate?: GroupCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPost', 'accountId', accountId)
            const localVarPath = `/groups/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGet(accountId, id, forceRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsInviteCode(accountId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsInviteCode(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsJoin(accountId: string, id: string, code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsJoin(accountId, id, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsLeave(accountId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsLeave(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPatch(accountId, id, groupAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPost(accountId: string, groupCreate?: GroupCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPost(accountId, groupCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsGet(accountId, id, forceRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode(accountId: string, id: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.groupsInviteCode(accountId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin(accountId: string, id: string, code: string, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsJoin(accountId, id, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave(accountId: string, id: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.groupsLeave(accountId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPatch(accountId, id, groupAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(accountId: string, groupCreate?: GroupCreate, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPost(accountId, groupCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get metadata for a group
     * @param {string} accountId 
     * @param {string} id 
     * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: any) {
        return GroupsApiFp(this.configuration).groupsGet(accountId, id, forceRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invite code for a group
     * @param {string} accountId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsInviteCode(accountId: string, id: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsInviteCode(accountId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a group using invite code
     * @param {string} accountId 
     * @param {string} id 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsJoin(accountId: string, id: string, code: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsJoin(accountId, id, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a group
     * @param {string} accountId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsLeave(accountId: string, id: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsLeave(accountId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group
     * @param {string} accountId 
     * @param {string} id 
     * @param {GroupAction} [groupAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: any) {
        return GroupsApiFp(this.configuration).groupsPatch(accountId, id, groupAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {string} accountId 
     * @param {GroupCreate} [groupCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPost(accountId: string, groupCreate?: GroupCreate, options?: any) {
        return GroupsApiFp(this.configuration).groupsPost(accountId, groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete: async (accountId: string, chatId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesDelete', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesDelete', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesDelete', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clears all pending messages
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending: async (accountId?: string, chatId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward: async (accountId: string, chatId: string, id: string, toChatId: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesForward', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesForward', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesForward', 'id', id)
            // verify required parameter 'toChatId' is not null or undefined
            assertParamExists('messagesForward', 'toChatId', toChatId)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/forward`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)

            if (toChatId) {
                localVarQueryParameter['toChatId'] = toChatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending'} [status] fetch only \&quot;notes\&quot; or \&quot;pending\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet: async (accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesGet', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesGet', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (forceReload !== undefined) {
                localVarQueryParameter['forceReload'] = forceReload;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch: async (accountId: string, chatId: string, id: string, inlineObject1?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPatch', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPatch', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesPatch', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId 
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost: async (accountId: string, chatId: string, messageCompose?: MessageCompose, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPost', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPost', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh: async (accountId: string, chatId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesRefresh', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesRefresh', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesRefresh', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch: async (q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('messagesSearch', 'q', q)
            const localVarPath = `/messages/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnChats !== undefined) {
                localVarQueryParameter['returnChats'] = returnChats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDelete(accountId: string, chatId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDelete(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clears all pending messages
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDeletePending(accountId?: string, chatId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDeletePending(accountId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesForward(accountId: string, chatId: string, id: string, toChatId: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesForward(accountId, chatId, id, toChatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending'} [status] fetch only \&quot;notes\&quot; or \&quot;pending\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesGet(accountId, chatId, beforeId, count, forceReload, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatch(accountId: string, chatId: string, id: string, inlineObject1?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatch(accountId, chatId, id, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId 
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPost(accountId: string, chatId: string, messageCompose?: MessageCompose, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPost(accountId, chatId, messageCompose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesRefresh(accountId: string, chatId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesRefresh(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSearch(q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSearch(q, accountId, chatId, page, count, returnChats, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(accountId: string, chatId: string, id: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.messagesDelete(accountId, chatId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clears all pending messages
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending(accountId?: string, chatId?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.messagesDeletePending(accountId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward(accountId: string, chatId: string, id: string, toChatId: Array<string>, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.messagesForward(accountId, chatId, id, toChatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending'} [status] fetch only \&quot;notes\&quot; or \&quot;pending\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet(accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending', options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.messagesGet(accountId, chatId, beforeId, count, forceReload, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch(accountId: string, chatId: string, id: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<Message> {
            return localVarFp.messagesPatch(accountId, chatId, id, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId 
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost(accountId: string, chatId: string, messageCompose?: MessageCompose, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.messagesPost(accountId, chatId, messageCompose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh(accountId: string, chatId: string, id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.messagesRefresh(accountId, chatId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch(q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.messagesSearch(q, accountId, chatId, page, count, returnChats, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a message
     * @param {string} accountId 
     * @param {string} chatId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDelete(accountId: string, chatId: string, id: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesDelete(accountId, chatId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clears all pending messages
     * @param {string} [accountId] If specified, only clears messages of this account
     * @param {string} [chatId] If specified, only clears messages of this chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDeletePending(accountId?: string, chatId?: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesDeletePending(accountId, chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} chatId 
     * @param {string} id 
     * @param {Array<string>} toChatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesForward(accountId: string, chatId: string, id: string, toChatId: Array<string>, options?: any) {
        return MessagesApiFp(this.configuration).messagesForward(accountId, chatId, id, toChatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch messages of the chat
     * @param {string} accountId 
     * @param {string} chatId 
     * @param {string} [beforeId] Get messages before this message ID
     * @param {number} [count] Number of messages to fetch
     * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
     * @param {'note' | 'pending'} [status] fetch only \&quot;notes\&quot; or \&quot;pending\&quot; messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesGet(accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending', options?: any) {
        return MessagesApiFp(this.configuration).messagesGet(accountId, chatId, beforeId, count, forceReload, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can reschedule a message, update the content of a note or mark it as resolved 
     * @summary Modify a message/note
     * @param {string} accountId 
     * @param {string} chatId 
     * @param {string} id 
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatch(accountId: string, chatId: string, id: string, inlineObject1?: InlineObject1, options?: any) {
        return MessagesApiFp(this.configuration).messagesPatch(accountId, chatId, id, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message
     * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
     * @param {string} chatId 
     * @param {MessageCompose} [messageCompose] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPost(accountId: string, chatId: string, messageCompose?: MessageCompose, options?: any) {
        return MessagesApiFp(this.configuration).messagesPost(accountId, chatId, messageCompose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh a message, in case the media expired
     * @param {string} accountId 
     * @param {string} chatId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesRefresh(accountId: string, chatId: string, id: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesRefresh(accountId, chatId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search messages
     * @param {string} q 
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {string} [chatId] 
     * @param {number} [page] Page number
     * @param {number} [count] Number of messages to fetch
     * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSearch(q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).messagesSearch(q, accountId, chatId, page, count, returnChats, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsDelete', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_DELETE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPost', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsDelete(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsDelete(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(name, tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(name: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.tagsDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.tagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): AxiosPromise<Tag> {
            return localVarFp.tagsPost(name, tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a tag
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDelete(name: string, options?: any) {
        return TagsApiFp(this.configuration).tagsDelete(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(options?: any) {
        return TagsApiFp(this.configuration).tagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a tag
     * @param {string} name 
     * @param {Array<string>} [tags] Get contacts who fall in either of these tags
     * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
     * @param {Array<string>} [contacts] Get these specific contact ids
     * @param {Array<string>} [notContacts] Do not get these specific contacts
     * @param {number} [minMessagesSent] Minimum messages sent
     * @param {number} [minMessagesRecv] Minimum messages received
     * @param {number} [maxMessagesSent] Maximum messages sent
     * @param {number} [maxMessagesRecv] Maximum messages received
     * @param {string} [q] Search string for contact name/phone number/email
     * @param {Array<string>} [assignee] Get contacts assigned to the specified users
     * @param {Array<string>} [accountId] Get contacts only belonging to this account
     * @param {'group' | 'individual'} [type] only get contacts of type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPost(name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any) {
        return TagsApiFp(this.configuration).tagsPost(name, tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(this.axios, this.basePath));
    }
}


